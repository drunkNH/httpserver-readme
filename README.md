>This is a README from a private repo named 'httpserver'
# Audit-Logged Work-Queue based HTTPServer
This is a program made for CSE130 that is an HTTP server, running forever waiting for requests from a client. The server can perform GET, PUT, and APPEND methods to a file, and contain an audit log, which will log the requests that was made to it in the order that the servers receives and process the requests. This server has multithreaded capabilities, containing a work queue which will use multiple threads to process a concurrent amount of clients. The server's threads must be efficient to serve multiple clients at a time, rather than one client at a time, for efficiency. Finally, the server should be atomic and coherent when processing requests.
# Design Documentation
### Data Structures and Algorithms used in Audit-Logged Work-Queue based HTTPServer 
**Data Structure in this program:**
- Many Character arrays were used in order to listen to the request in the socket, parse through the data that was read, retrieve important information that was parsed, and writing a response to the socket for the client to receive, dependant on the type of operation and if the server was able to perform the operation. It was also used in order to create an log entry in order to log each request the server received and performed. Struct stat is another data structure used to retrieve data on the file that was passed, used to handle errors for erronous files passed. A global int array was used as a queue, to enqueue client requests for the worker threads to process later. The program uses epoll, in order to detect when a client has sent some sort of data to the server.

**Algorithms in this program** 
- The program is multithreaded, having the main thread act as a dispatcher thread and wait for connections. Once the dispatcher thread receives a connection, it will use epoll to acertain if the connection contains data. If the connection contains data, check if the data contains a valid request, and if it does, enqueue that connection to a queue that the worker threads can access, and it will signal the worker threads to try and process the request.
- The worker threads will sleep until it receives a signal that there is work to be done. It will search for a request it can process, dequeue the request from the queue, and call handle_connection on the valid request. The threads will have a lock during its critical sections, namely when dequeuing from the thread and handling the connection. After a request is processed, the thread will unlock for other threads to try to do more work if availiable. 
- An algorithm, named handle_connection, is used for reading and storing the request-line and headers, without reading the message body. To do this, it read byte by byte, storing each byte in a char array meant to store the request line and headers, and continue this reading until the storage contains "\r\n\r\n". If the program has read more than 2048 bytes while not containing "\r\n\r\n", it will stop reading the request and move to another request, writing the appropriate status response to the client.
- The program will try to parse the method and the URI from the request, using strtok_r to find each relevant line that needs to be logged. It will also attempt to find an Request-Id header. If an Request-Id was found, parse the ID value, if not, have the ID default to 0. Once it has parsed the necessary data to log an entry, it will wait until the program has processed and completed the request. All method functions will return an integer status, which is the status code that was given after the request was processed. The program will then log this entry to a text file named log.txt, in the form "(METHOD),(URI),(STATUS CODE),(ID)". Each execution of HTTPServer will overwrite log.txt to be an empty file, if not creating a new log.txt, and append each entry to the current log.txt.
- Regex was used extensively in this program. The first instance of regex being used is for method. Regex will check which method was called, checking if a method is GET, PUT, or APPEND, and call the appropriate matching function for the method requested. If the regex was not matched, the program will not call any method functions, and will respond with the appropriate status response.
- If GET function was called, the program will parse the URI, and check if the file is a valid file to perform operations. If the file was valid, the program will display a status response that the operation was successful, and write to the socket the contents of the file.
- If PUT function was called, the program will first check everything about the request sent. REGEX is used to determine if a line is valid, and strtok_r is used in order to tokenize the request line by line, using "\r\n" as the delimiter. It will check if the file is valid, if the headers given were valid, and especially if the "Content-Length: " header was given. If a "Expect-100: Continue" header was given, the server will pause temporarily so that the message body is sent. If a request is invalid in anyway, the appropriate status code is written. Otherwise, the program will read the message body, and write what was read in the message-body to the file given by the URI, writing up to the bytes set by Content-Length. If the file did not previously exist in the directory, the program will create a file and write to it. Afterwards, depending on whether the file given by the URI was created, the appropriate status response will be written.
- If APPEND function was called, it will work similarly to the PUT function. Some fundamental differences with append is that APPEND will append to a file, that is, write to the end of the file instead of overwriting the file, and requires an existing file in the directory, that is, it does not create a file if the file does not exist in the directory. Appropriate status responses are written after the APPEND algorithm is completed.
- a writeStatus algorithm was created to streamline writing status responses to the client. It contains all status responses that can be written, and the algorithm will write the appropriate status response depending on the status code that was sent.

### Requirements that Audit-Logged Work-Queue based HTTPServer Overcomes
There are several requirements that Audit-Logged Work-Queue based HTTPServer overcomes
1. Reading and performing a request in an efficent manner
    - As stated before, the program first reads the request-line and the headers to "\r\n\r\n", just before the message body. This is done so that the program preserves the message body in the socket, so that the program doesn't need to try and handle the message-body in the case something errornous happens when handling the message body. While it is slower to read byte by byte instead of reading many bytes as once from the socket, it is an acceptable tradeoff as the program only reads up to 2048, which does not harm overall efficiency while increases the precision of reading up to "\r\n\r\n".
    - The program will call the matching function of the method in the request. Once the program parses important information such as URI for get, URI and Content-Length for PUT and APPEND, determines that the request is valid, and determines the actions on the file is valid, the program will perform the method operation, which is as follows:
        - GET will write to the socket for the client the contents that is inside of the file given by the URI.
        - PUT will overwrite to the given URI file, writing the message-body to the file, up to the bytes set by Content-Length. If the file did not exists in the directory, it will be created and have the message body written to the created file.
        - APPEND will append to the given URI file, writing the message-body starting at the end of the file, up to the bytes set by Content-Length.
    - After a request has been handled, the server will continue to listen indefinitely, waiting for more requests. These operations are efficient for large content as the operations read and write many bytes as once. The operations reads and writes 4096 bytes at once, until it has reached EOF for their respective files (GET reads a file, writes to socket; PUT and APPEND reads message-body from socket, writes to a file).
2. Handling invalid requests
    - Invalid requests, if determined if exists, will be handled appropriately. Invalid requests ranges from the following:
        - Invalid Method: Method was not GET, PUT, or APPEND.
        - Invalid File: Dependent on operation, but will not perform if an Invalid File was detected. This occurs if a file is a directory, file has certain permissions that denies access, or file does not exist (used for GET and APPEND, not for PUT).
        - Invalid Protocol: The protocol the request gives is required to be HTTP/1.1, and will be invalid otherwise.
        - Invalid Headers: Headers must follow a "key: value" rule. If a header is found to be in violation, the request is invalid.
        - Invalid Content-Length: Content-Length must be present for PUT and APPEND requests. The request will be invalid if the Content-Length header is missing, or if the Content-Length is not an integer.
    - Any of these invalid parameters will cease the operation of the method from being performed, writing the appropriate status response, leaving the function, and wait for future requests.
3. Writing responses to the client
    - The program must write a response to the client, indicating what occured on the server side. The program uses a status variable, which is set to values depending on the request and what occured in an operation of a request. The status codes are as follows:
        - 501: This status code will be written if the method was not the following (GET, PUT, APPEND).
        - 500: This status code is a generic catch-all error. The status variable is set to 500 in the beginning, so if an error occurs and the status remains to be 500 the request was not invalid however the server suffered an issue that halted processing.
        - 404: This status code is used for the operations GET and APPEND. The file given by the URI does not exist in the directory, so GET and APPEND can not perform operations on a non-existing file. It is not used in PUT as PUT creates a file if it does not exists.
        - 403: This status code is used when a file has permissions such that it can not be open, the URI given started with // e.g "//foo.txt", or the file was a directory.
        - 400: This status code is used when a request was not formatted correctly, which are Invalid Protocol, Headers, and Content-Length.
        - 200: This status code is used when an request was a valid request, and the meethod was able to perform its operation successfully without any issue.
        - 201: This status code is used when PUT creates a file that did not exist previously in the directory. It writes this status in place of 200.
    - Once the program has determined the status code based on what occured in the operation (e.g perform operation successfully, detected invalid request, detected invalid file), the program send the set status code to the writeStatus algorithm, which will write to the socket the corresponding response of the status code to be displayed to the client.
After handling a request and writing a response to the client, the server will continue to execute indefinitely, waiting for more requests to be sent by the client.
4. Audit logging the requests in a durable manner
    - The program will first create/overwrite a log.txt, so each execution of HTTPServer contains its own logs, so that there is no overlap from previous execution. 
    - The program will ensure that the buffer did not receive an empty request, and if it did, continue to the next request. This ensures that the program will not deal with unintended behavior due to an empty request, which can cause segmentation faults as the next step may accidentally handle variables set to NULL with an empty request. 
    - With a valid request, the program will parse all relevant data (method, URI, status code, ID). The program will open the log.txt file with the append flag, log each entry to log.txt by appending it, flushing each log entry after being written, and closing the file. This ensures that the logging is durable, as each entry will be written to the log.txt file, and after being written the entry is flushed for potential future entries so that there's no remnants of the old entries.
5. Having the server run multiple threads successfully with proper synchronization in an efficient manner
    - The dispatcher thread will wait for connections. Once it's received a connection, it will use epoll to check if theres new data from the connection. If there is, check if the data contains a valid request, and if it does, enqueue the connection to the global variable queue, and wake up worker threads to process the work. The dispatcher thread has locks so that synchronization on the queue is synchronized.
    - The worker threads first lock the mutex to block other threads from entering the critical section, and will sleep when there is no work to be done. Once the worker threads received a signal that there's work to be done, the worker thread reobtains the lock and will dequeue a connection from the queue, and will call handle_connection to handle its connection. We then close it and unlock the mutex, so that other threads may acquire the lock.
    - Due to the locks critical section being strictly involving queue operations and handling connection, the dispatcher threads and worker threads works efficiently in a fast pace so that other threads, especially the dispatcher threads, can do work while a worker thread is handling a process.
    - If requests are sent sequentially and not concurrently, the dispatcher thread only needs to wake up one thread while other threads sleep, as only one thread is needed to handle one request at a time, which will decrease CPU usage so that the other threads are not working needlessly.
6. Ensuring atomicity and coherency
    - If we don't see a valid request from a client, we move on to the next client if there is any to see if a valid request came from them.
    - If a valid request was detected, handle and process that clients request before any other requests as the current request was valid first, even if other requests which are considered invalid came before the current one.
    - This ensures that a client isn't waiting on another client, and will be reflected in the audit log that say R1, which was not a complete request, and R2, a completed request, R2 will be processed first and be written in the log first, followed by R1.
